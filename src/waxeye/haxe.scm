;; Waxeye Parser Generator
;; www.waxeye.org
;; Copyright (C) 2008-2010 Orlando Hill
;; Licensed under the MIT license. See 'LICENSE' for details.

(module
haxe
mzscheme

(require (lib "ast.ss" "waxeye")
         (lib "fa.ss" "waxeye")
         (only (lib "list.ss" "mzlib") filter)
         "code.scm" "dfa.scm" "gen.scm" "util.scm")
(provide gen-haxe)


(define *haxe-parser-name* "")
(define *haxe-node-name* "")
(define *haxe-tree-type* "")


(define (haxe-comment lines)
  (comment-bookend "/*" " *" " */" lines))


(define (haxe-doc . lines)
  (comment-bookend "/**" " *" " */" lines))


(define (haxe-header-comment)
  (if *file-header*
      (haxe-comment *file-header*)
      (haxe-comment *default-header*)))


(define (gen-haxe-names)
  (set! *haxe-node-name* (if *name-prefix*
                             (string-append *name-prefix* "Type")
                             "Type"))
  (set! *haxe-parser-name* (if *name-prefix*
                               (string-append *name-prefix* "Parser")
                               "Parser"))
  (set! *haxe-tree-type* (string-append "IAST<" *haxe-node-name* ">")))


(define (gen-haxe grammar path)
  (gen-haxe-names)
  (let ((type-file (string-append path *haxe-node-name* ".hx"))
        (parser-file (string-append path *haxe-parser-name* ".hx")))
    (dump-string (haxe-type grammar) type-file)
    (dump-string (haxe-parser grammar) parser-file)
    (list type-file parser-file)))


(define (haxe-type grammar)
  (let ((non-terms (get-non-terms grammar)))
    (format "~a~a\n~aenum ~a\n{\n~a}\n"
            (haxe-header-comment)
            (gen-haxe-package)
            (haxe-doc "The types of AST nodes." "" "@author Waxeye Parser Generator")
            *haxe-node-name*
            (indent (string-append
                     (ind) "_Empty;\n"
                     (ind) "_Char;\n"
                     (ind) "_Pos;\n"
                     (ind) "_Neg;"
                     (string-concat (map (lambda (a)
                                           (format "\n~a~a;"
                                                   (ind)
                                                   (camel-case-upper a)))
                                         non-terms))
                     "\n")))))


(define (haxe-parser grammar)
  (format "~a~a\n~a~aclass ~a extends org.waxeye.parser.Parser<~a>\n{\n~a}\n"
          (haxe-header-comment)
          (gen-haxe-package)
          (gen-haxe-imports)
          (haxe-doc "A parser generated by the Waxeye Parser Generator." "" "@author Waxeye Parser Generator")
          *haxe-parser-name*
          *haxe-node-name*
          (indent (string-append (gen-constructor) "\n" (gen-make-automata (make-automata grammar))))))


(define (gen-haxe-package)
  (if *module-name*
      (format "package ~a;\n" *module-name*)
      "package;"))    


(define (gen-haxe-imports)
"
import org.waxeye.parser.AutomatonTransition;
import org.waxeye.parser.CharTransition;
import org.waxeye.parser.Edge;
import org.waxeye.parser.FA;
import org.waxeye.parser.State;
import org.waxeye.parser.WildCardTransition;
")


(define (gen-constructor)
  (format "~a~apublic function new()\n~a{\n~a~a}\n"
          (haxe-doc (format "Creates a new ~a." *haxe-parser-name*))
          (ind)
          (ind)
          (indent
           (format "~asuper(makeAutomata(), true, ~a, ~a._Empty, ~a._Char, ~a._Pos, ~a._Neg);\n"
                   (ind)
                   *start-index*
                   *haxe-node-name*
                   *haxe-node-name*
                   *haxe-node-name*
                   *haxe-node-name*))
          (ind)))


;; I could not get for/list or in-range to work, so defined the following. There must be a better way.
(define (range from to)
  (cond
    ((equal? from to) null)
    (else (cons from (range (+ from 1) to)))
  )
)
          
          
(define (gen-make-automata automata)
  (let* ((automata-list (vector->list automata))
         (a-names (map method-name automata-list (range 0 (length automata-list))))
        )
    (format "~a~aprivate static function makeAutomata():List<FA<~a>>\n~a{\n~a~a}\n~a\n"
            (haxe-doc "Builds the automata for the parser." "" "@return The automata for the parser.")
            (ind)
            *haxe-node-name*
            (ind)
            (indent
             (string-append
              (format "~avar automata:List<FA<~a>> = new List<FA<~a>>();\n" (ind) *haxe-node-name* *haxe-node-name*)
              "\n"
              (string-concat (map gen-fa-call a-names))
              (string-append (ind) "return automata;\n")))
            (ind)
            (string-concat (map gen-fa automata-list a-names))
)))

  
(define (method-name a i)
  (let ((type (fa-type a)))
    (cond
     ((equal? type '&) (format "initPos_~a" i))
     ((equal? type '!) (format "initNeg_~a" i))
     (else (format "init~a" (camel-case-upper (symbol->string type)))))
))
  
  
(define (gen-fa-call aname)
  (format "~a~a(automata);\n" (ind) aname))


(define (gen-fa a aname)
  (format "\n~aprivate static function ~a(List<FA<~a>> automata):Void {\n~a~a}\n"
          (ind)
          aname
          *haxe-node-name*
          (indent (string-append
            (format "~avar states:List<State<~a>> = new List<State<~a>>();\n" (ind) *haxe-node-name* *haxe-node-name*)
            (format "~avar edges:List<Edge<~a>> = new List<Edge<~a>>();\n" (ind) *haxe-node-name* *haxe-node-name*)
            (string-concat (map gen-state (vector->list (fa-states a))))
            (format "~aautomata.add(new FA<~a>(~a.~a, ~a, states));\n"
                    (ind)
                    *haxe-node-name*
                    *haxe-node-name*
                    (let ((type (fa-type a)))
                      (cond
                       ((equal? type '&) "_Pos")
                       ((equal? type '!) "_Neg")
                       (else
                        (camel-case-upper (symbol->string type)))))
                    (case (fa-mode a)
                      ((voidArrow) "FA.VOID")
                      ((pruneArrow) "FA.PRUNE")
                      ((leftArrow) "FA.LEFT")))
          ))
          (ind)))


(define (gen-state s)
  (format "~aedges = new List<Edge<~a>>();\n~a~astates.add(new State<~a>(edges, ~a));\n"
          (ind)
          *haxe-node-name*
          (string-concat (map gen-edge (state-edges s)))
          (ind)
          *haxe-node-name*
          (bool->s (state-match s))))


(define (gen-edge e)
  (format "~aedges.add(new Edge<~a>(new ~a, ~a, ~a));\n"
          (ind)
          *haxe-node-name*
          (gen-trans (edge-t e))
          (edge-s e)
          (bool->s (edge-v e))))


(define (gen-trans t)
  (cond
   ((equal? t 'wild) (gen-wild-card-trans))
   ((integer? t) (gen-automaton-trans t))
   ((char? t) (gen-char-trans t))
   ((pair? t) (gen-char-class-trans t))))


(define (gen-automaton-trans t)
  (format "AutomatonTransition<~a>(~a)" *haxe-node-name* t))


(define (gen-char-trans t)
  (format "CharTransition<~a>(new char[]{~a}, new char[]{}, new char[]{})" *haxe-node-name* (gen-char t)))


(define (gen-char-class-trans t)
  (let* ((single (filter char? t))
         (ranges (filter pair? t))
         (min (map car ranges))
         (max (map cdr ranges)))
    (format "CharTransition<~a>(~a, ~a, ~a)"
            *haxe-node-name*
            (gen-char-list single)
            (gen-char-list min)
            (gen-char-list max))))


(define (gen-char-list l)
  (format "new char[]{~a}"
          (if (null? l)
              ""
              (string-append
               (gen-char (car l))
               (string-concat (map (lambda (a)
                                     (string-append ", " (gen-char a)))
                                   (cdr l)))))))


(define (gen-char t)
  (format "'~a~a'"
          (if (escape-for-java-char? t) "\\" "")
          (cond
           ((equal? t #\linefeed) "\\n")
           ((equal? t #\tab) "\\t")
           ((equal? t #\return) "\\r")
           (else t))))


(define (gen-wild-card-trans)
  (format "WildCardTransition<~a>()" *haxe-node-name*))

)
